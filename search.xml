<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[IOS编译打包提交自动化]]></title>
      <url>http://xenobladex.github.io/2016/05/31/IOS%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>该操作是指：首先对Xcode的Project或Workspace进行编译，编译通过的应用会生成app文件，为了提供给测试使用，我们需要将.app包转为.ipa包</p>
<p>实现方法有两种，AppleScript和Shell脚本</p>
<p>Shell脚本下一个值得参考的样例是<a href="https://github.com/webfrogs/xcode_shell" target="_blank" rel="external">webfrogs/xcode_shell</a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>工具：</p>
<ul>
<li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html" target="_blank" rel="external">xcodebuild</a>：主要用来编译、打包成Archive和导出ipa包</li>
<li>xcrun：用于打包</li>
<li>altool：ApplicationLoader，提交应用</li>
<li>fir-cli：上传到fir</li>
<li>PlistBuddy：读写plist文件</li>
</ul>
<p><code>xcodebuild</code>和<code>xcrun</code>都来自<code>Command Line Tools</code>，需要在Xcode或终端中安装。</p>
<h2 id="Shell实现"><a href="#Shell实现" class="headerlink" title="Shell实现"></a>Shell实现</h2><ul>
<li>ipa-build：编译xcode工程并生成ipa文件</li>
<li>ipa-publish：生成符合itms—services协议的文件，并发不到服务器</li>
<li>sendEmail：stmp发布email的脚本。（可以改成Applescipt来实现）</li>
<li>sftpDownloadFile：用过sftp协议下载文件</li>
<li>sftpUploadFile：通过sftp协议上传文件</li>
<li>updateLocalIndexHtml：对索引文件进行处理（二进制文件，非shell脚本）</li>
<li>uploadItemsServicesFiles：将itms-services协议文件上传到服务器</li>
</ul>
<h3 id="ipa-build"><a href="#ipa-build" class="headerlink" title="ipa-build"></a>ipa-build</h3><ol>
<li><p>使用方法：<br> <code>ipa-build 脚本绝对路径 参数1 参数2</code></p>
<p> 参数1为IOS工程的跟路径；参数2可选，为编译是工程configuration的类型：Debug、AdHoc、Release、Distribution，默认为Release。</p>
<p> ipa-build脚本运行后，会在IOS工程根路径下生成名为“build”的文件夹，在这个文件夹中又有一个名为“ipa-build”的文件夹，打包所生成的最新ipa包就在其中。</p>
</li>
<li><p>源码分析</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># 功能：编译xcode项目并打ipa包</span></span><br><span class="line"><span class="comment"># 使用说明：</span></span><br><span class="line"><span class="comment">#		编译project</span></span><br><span class="line"><span class="comment">#			ipa-build &lt;project directory&gt; [-c &lt;project configuration&gt;] [-o &lt;ipa output directory&gt;] [-t &lt;target name&gt;] [-n] [-p &lt;platform identifier&gt;]</span></span><br><span class="line"><span class="comment">#		编译workspace</span></span><br><span class="line"><span class="comment">#			ipa-build  &lt;workspace directory&gt; -w -s &lt;schemeName&gt; [-c &lt;project configuration&gt;] [-n]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 参数说明：-c NAME				工程的configuration,默认为Release。</span></span><br><span class="line"><span class="comment">#			-o PATH				生成的ipa文件输出的文件夹（必须为已存在的文件路径）默认为工程根路径下的”build/ipa-build“文件夹中</span></span><br><span class="line"><span class="comment">#			-t NAME				需要编译的target的名称</span></span><br><span class="line"><span class="comment">#			-w					编译workspace	</span></span><br><span class="line"><span class="comment">#			-s NAME				对应workspace下需要编译的scheme</span></span><br><span class="line"><span class="comment">#			-n					编译前是否先clean工程</span></span><br><span class="line"><span class="comment">#			-p					平台标识符</span></span><br><span class="line"><span class="comment"># 作者：ccf</span></span><br><span class="line"><span class="comment"># E-mail:ccf.developer@gmail.com</span></span><br><span class="line"><span class="comment"># 创建日期：2012/09/24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数个数不能小于1</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> <span class="_">-lt</span> 1 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! Should enter the root directory of xcode project after the ipa-build command."</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 判断第一个参数提供的目录是否存在，其他命令有-f，-s，-e</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="_">-d</span> <span class="variable">$1</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! The first param must be a directory."</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程绝对路径</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line"><span class="comment"># 当前目录的全路径名称</span></span><br><span class="line">project_path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="comment">#编译的configuration，默认为Release</span></span><br><span class="line">build_config=Release</span><br><span class="line"><span class="comment"># 设置参数名</span></span><br><span class="line">param_pattern=<span class="string">":p:nc:o:t:ws:"</span></span><br><span class="line">OPTIND=2</span><br><span class="line"><span class="comment"># 遍历参数</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$optname</span>"</span> <span class="keyword">in</span>       </span><br><span class="line"><span class="string">"n"</span>) </span><br><span class="line"><span class="comment"># 是否清理工程</span></span><br><span class="line">should_clean=y		</span><br><span class="line">;;</span><br><span class="line"><span class="string">"p"</span>)</span><br><span class="line">tmp_optind=<span class="variable">$OPTIND</span></span><br><span class="line">tmp_optname=<span class="variable">$optname</span></span><br><span class="line">tmp_optarg=<span class="variable">$OPTARG</span></span><br><span class="line"></span><br><span class="line">OPTIND=<span class="variable">$OPTIND</span>-1</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname ;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error argument value for option <span class="variable">$tmp_optname</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OPTIND=<span class="variable">$tmp_optind</span></span><br><span class="line"><span class="comment"># 平台标志符</span></span><br><span class="line">platform_id=<span class="variable">$tmp_optarg</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="string">"c"</span>)        </span><br><span class="line">tmp_optind=<span class="variable">$OPTIND</span></span><br><span class="line">tmp_optname=<span class="variable">$optname</span></span><br><span class="line">tmp_optarg=<span class="variable">$OPTARG</span></span><br><span class="line">OPTIND=<span class="variable">$OPTIND</span>-1</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname ;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error argument value for option <span class="variable">$tmp_optname</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OPTIND=<span class="variable">$tmp_optind</span></span><br><span class="line"><span class="comment"># 设定工程的configuration</span></span><br><span class="line">build_config=<span class="variable">$tmp_optarg</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="string">"o"</span>)</span><br><span class="line">tmp_optind=<span class="variable">$OPTIND</span></span><br><span class="line">tmp_optname=<span class="variable">$optname</span></span><br><span class="line">tmp_optarg=<span class="variable">$OPTARG</span></span><br><span class="line"></span><br><span class="line">OPTIND=<span class="variable">$OPTIND</span>-1</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname ;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error argument value for option <span class="variable">$tmp_optname</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OPTIND=<span class="variable">$tmp_optind</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$tmp_optarg</span></span><br><span class="line"><span class="comment"># 输出文件夹</span></span><br><span class="line">output_path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;project_path&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="_">-d</span> <span class="variable">$output_path</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error!The value of option o must be an exist directory."</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="string">"w"</span>)</span><br><span class="line">workspace_name=<span class="string">'*.xcworkspace'</span></span><br><span class="line"><span class="comment"># 查看该路径下是否有xcworkspace文件</span></span><br><span class="line">ls <span class="variable">$project_path</span>/<span class="variable">$workspace_name</span> &amp;&gt;/dev/null</span><br><span class="line">rtnValue=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$rtnValue</span> = 0 ];<span class="keyword">then</span></span><br><span class="line">build_workspace=$(<span class="built_in">echo</span> $(basename <span class="variable">$project_path</span>/<span class="variable">$workspace_name</span>))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error!Current path is not a xcode workspace.Please check, or do not use -w option."</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="string">"s"</span>)</span><br><span class="line">tmp_optind=<span class="variable">$OPTIND</span></span><br><span class="line">tmp_optname=<span class="variable">$optname</span></span><br><span class="line">tmp_optarg=<span class="variable">$OPTARG</span></span><br><span class="line"></span><br><span class="line">OPTIND=<span class="variable">$OPTIND</span>-1</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname ;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error argument value for option <span class="variable">$tmp_optname</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OPTIND=<span class="variable">$tmp_optind</span></span><br><span class="line"><span class="comment"># workspace下需要编译的scheme</span></span><br><span class="line">build_scheme=<span class="variable">$tmp_optarg</span></span><br><span class="line">;;</span><br><span class="line"><span class="string">"t"</span>)</span><br><span class="line">tmp_optind=<span class="variable">$OPTIND</span></span><br><span class="line">tmp_optname=<span class="variable">$optname</span></span><br><span class="line">tmp_optarg=<span class="variable">$OPTARG</span></span><br><span class="line"></span><br><span class="line">OPTIND=<span class="variable">$OPTIND</span>-1</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getopts</span> <span class="variable">$param_pattern</span> optname ;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"Error argument value for option <span class="variable">$tmp_optname</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">OPTIND=<span class="variable">$tmp_optind</span></span><br><span class="line"><span class="comment"># 编译目标的名称</span></span><br><span class="line">build_target=<span class="variable">$tmp_optarg</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"?"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! Unknown option <span class="variable">$OPTARG</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line"><span class="string">":"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! No argument value for option <span class="variable">$OPTARG</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="comment"># Should not occur</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! Unknown error while processing options"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#build文件夹路径</span></span><br><span class="line">build_path=<span class="variable">$&#123;project_path&#125;</span>/build</span><br><span class="line"><span class="comment">#生成的app文件目录</span></span><br><span class="line">appdirname=Release-iphoneos</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$build_config</span> = Debug ];<span class="keyword">then</span></span><br><span class="line">appdirname=Debug-iphoneos</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$build_config</span> = Distribute ];<span class="keyword">then</span></span><br><span class="line">appdirname=Distribute-iphoneos</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#编译后文件路径(仅当编译workspace时才会用到)</span></span><br><span class="line">compiled_path=<span class="variable">$&#123;build_path&#125;</span>/<span class="variable">$&#123;appdirname&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否clean</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$should_clean</span>"</span> = <span class="string">"y"</span> ];<span class="keyword">then</span></span><br><span class="line">xcodebuild clean -configuration <span class="variable">$&#123;build_config&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#组合编译命令</span></span><br><span class="line">build_cmd=<span class="string">'xcodebuild'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$build_workspace</span>"</span> != <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="comment">#编译workspace</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$build_scheme</span>"</span> = <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error! Must provide a scheme by -s option together when using -w option to compile a workspace."</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">build_cmd=<span class="variable">$&#123;build_cmd&#125;</span><span class="string">' -workspace '</span><span class="variable">$&#123;build_workspace&#125;</span><span class="string">' -scheme '</span><span class="variable">$&#123;build_scheme&#125;</span><span class="string">' -configuration '</span><span class="variable">$&#123;build_config&#125;</span><span class="string">' CONFIGURATION_BUILD_DIR='</span><span class="variable">$&#123;compiled_path&#125;</span><span class="string">' ONLY_ACTIVE_ARCH=NO'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">#编译project</span></span><br><span class="line">build_cmd=<span class="variable">$&#123;build_cmd&#125;</span><span class="string">' -configuration '</span><span class="variable">$&#123;build_config&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$build_target</span>"</span> != <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">build_cmd=<span class="variable">$&#123;build_cmd&#125;</span><span class="string">' -target '</span><span class="variable">$&#123;build_target&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译工程</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$project_path</span></span><br><span class="line"><span class="variable">$build_cmd</span> || <span class="built_in">exit</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment">#进入build路径</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$build_path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建ipa-build文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="_">-d</span> ./ipa-build ];<span class="keyword">then</span></span><br><span class="line">rm -rf ipa-build</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">mkdir ipa-build</span><br><span class="line"></span><br><span class="line"><span class="comment">#app文件名称</span></span><br><span class="line">appname=$(basename ./<span class="variable">$&#123;appdirname&#125;</span>/*.app)</span><br><span class="line"><span class="comment">#通过app文件名获得工程target名字</span></span><br><span class="line">target_name=$(<span class="built_in">echo</span> <span class="variable">$appname</span> | awk -F. <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="comment">#app文件中Info.plist文件路径</span></span><br><span class="line">app_infoplist_path=<span class="variable">$&#123;build_path&#125;</span>/<span class="variable">$&#123;appdirname&#125;</span>/<span class="variable">$&#123;appname&#125;</span>/Info.plist</span><br><span class="line"><span class="comment">#取版本号</span></span><br><span class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c <span class="string">"print CFBundleShortVersionString"</span> <span class="variable">$&#123;app_infoplist_path&#125;</span>)</span><br><span class="line"><span class="comment">#取build值</span></span><br><span class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c <span class="string">"print CFBundleVersion"</span> <span class="variable">$&#123;app_infoplist_path&#125;</span>)</span><br><span class="line"><span class="comment">#取displayName</span></span><br><span class="line">displayName=$(/usr/libexec/PlistBuddy -c <span class="string">"print CFBundleDisplayName"</span> <span class="variable">$&#123;app_infoplist_path&#125;</span>)</span><br><span class="line"><span class="comment">#IPA名称</span></span><br><span class="line">ipa_name=<span class="string">"<span class="variable">$&#123;displayName&#125;</span>_<span class="variable">$&#123;platform_id&#125;</span>_<span class="variable">$&#123;bundleShortVersion&#125;</span>_<span class="variable">$&#123;build_config&#125;</span>_<span class="variable">$&#123;bundleVersion&#125;</span>_<span class="variable">$(date +"%Y%m%d")</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ipa_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#xcrun打包</span></span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v ./<span class="variable">$&#123;appdirname&#125;</span>/*.app -o <span class="variable">$&#123;build_path&#125;</span>/ipa-build/<span class="variable">$&#123;ipa_name&#125;</span>.ipa || <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$output_path</span>"</span> != <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">cp <span class="variable">$&#123;build_path&#125;</span>/ipa-build/<span class="variable">$&#123;ipa_name&#125;</span>.ipa <span class="variable">$output_path</span>/<span class="variable">$&#123;ipa_name&#125;</span>.ipa</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Copy ipa file successfully to the path <span class="variable">$output_path</span>/<span class="variable">$&#123;ipa_name&#125;</span>.ipa"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AppleScript实现"><a href="#AppleScript实现" class="headerlink" title="AppleScript实现"></a>AppleScript实现</h2><p>相比shell，appleScript的简易性以及对mac OS系统的接口支持使其能够更好的在mac下工作，虽然该语言已经渐渐被大家遗忘，但并不表示它不work，所以我打算使用applescript对上述流程进行复现，并非简单的抄袭，而是根据自身需要以及applescript的特性进行改进，部分实现如下：</p>
<p>applescript的存在形式有三种，一种是文本文件，与shell类似，在首行定义<code>#!/usr/bin/osascript</code>便可以在终端下运行；另一种是应用程序，通过双击来运行；还有一种是名为Droplet的应用程序，其特点是可以获取所有拖动到该应用图标上的文件的信息（支持多文件），于是我选择用第三种方式来传递工程路径，其他配置则设为默认值，实现一次拖动，完成自动编译和打包的过程。</p>
<h3 id="拖动操作的Handle"><a href="#拖动操作的Handle" class="headerlink" title="拖动操作的Handle"></a>拖动操作的Handle</h3><p>文件拖动到应用图标上方是通过Handle监听实现的：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> open these_items</span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">with</span> this_item <span class="keyword">in</span> these_items</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> open</span><br></pre></td></tr></table></figure>
<p>每个this_item为alias类型，代表其中一个被拖进图标的文件夹。</p>
<p>待续…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="http://zackzheng.info/2015/12/27/2015-12-27-an-automated-script-for-building-archiving-submission-sending-emails/#" target="_blank" rel="external">详解Shell脚本实现iOS自动化编译打包提交</a></p>
</li>
<li><p><a href="http://blog.csdn.net/ccf0703/article/details/8588667" target="_blank" rel="external">IOS工程自动打包并发布脚本实现</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XMPPFramework源码分析<三> - 流]]></title>
      <url>http://xenobladex.github.io/2016/05/31/XMPPFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>XMPPStream是XMPPFramework的<strong>核心</strong>，所有的消息的发送和接收都是在XMPPStream中进行的。借助CocoaAsyncSocket实现socket通信，申明了GCDAsyncSocketDelegate委托。</p>
<h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><ol>
<li>xmppQueue：线程队列</li>
<li>xmppQueueTag: 线程队列的标志符，用来找回标注过的线程</li>
<li>线程队列：willSendIqQueue、willSendMessageQueue、willSendPresenceQueue、willSendLoginQueue、willReceiveIqQueue、willReceiveMessageQueue、willReceivePresenceQueue、willReceiveLogin、didReceiveIqQueue</li>
<li>connectTimer：监视某些类型事件的对象</li>
<li>multicastDelegate：多重委托</li>
<li>state：枚举XMPPStreamState，表示连接状态</li>
<li>asyncSocket：GCDAsyncSocket的实例，负责socket的连接</li>
<li>parser：XMPPParser实例，负责处理接收到的流。</li>
<li>parserError</li>
<li>flags<ul>
<li>kP2PInitiator：P2P模式</li>
<li>kIsSecure：通过SSL/TLS保护连接</li>
<li>kIsAuthenticated：认证成功</li>
<li>kDidStartNegotiation：Negotiation已经至少开始了一次</li>
</ul>
</li>
<li>config<ul>
<li>kP2PMode：XMPPStream以P2P模式初始化</li>
<li>kResetByteCountPerConnection：字节计数每次连接都会清空</li>
<li>kEnableBackgroundingOnSocket：socket上设置为VOIP标志</li>
</ul>
</li>
<li>authenticationDate</li>
<li>myJID_setByClient：客户端设置的用户JID</li>
<li>myJID_setByServer：服务器设置的用户JID</li>
<li>remoteJID：</li>
<li>rootElement：接收到消息的根元素，包含服务器的配置信息。</li>
<li>lastSendReceiveTime：最近的socket通信时间</li>
<li>keepAliveData：心跳数据，可通过<code>(void)setKeepAliveWhitespaceCharacter:(char)keepAliveChar</code>来改变</li>
<li>registeredModules</li>
<li>autoDelegateDict</li>
<li>srvResolver：XMPPSRVResolver</li>
<li>srvResults：</li>
<li>srvResultsIndex</li>
<li>receipts</li>
<li>userTag</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在对属性赋值和取值时均要判断当前进程是否处在xmppQueue队列下：</p>
<ol>
<li><p>hostName（可选）</p>
<p> 建立TCP连接的服务器主机名，如果没有设置，则进行SRV查找</p>
</li>
<li><p>hostPort</p>
<p> xmpp服务器的端口，默认为5222</p>
</li>
<li><p>autoStartTLS</p>
<p> 是否开启安全传输层协议（TLS），默认为NO</p>
</li>
<li><p>myJID</p>
<p> 用户的JID，当连接时，JID的域名被用来确定xmpp虚拟主机；</p>
<p> 在注册和认证时可以利用用户名生成的JID进行通信。</p>
</li>
<li><p>remoteJID（只用于P2P）</p>
</li>
<li><p>keepAliveInterval：传送心跳数据的无连接时间间隔</p>
<p> xmpp支持传送心跳数据，传送的空白字符会被xmpp协议忽略，该数据只有在没有其他数据传送或接收时发送，当其他数据最后一次发送或接收时，开始计时，并在达到间隔时间时传送数据。</p>
</li>
<li><p>keepAliveWhitespaceCharacter</p>
<p> 可以设定心跳数据的字符串，只能是空格、Tab、回车</p>
</li>
<li><p>myPresence</p>
<p> myJID最近一次发送的presence元素</p>
</li>
<li><p>numberOfBytesSent/numberOfBytesReceived</p>
<p> 通过xmppStream接收或发送的总字节数</p>
</li>
<li><p>resetByteCountPerConnection</p>
<p>是否在新建连接前清空字节统计</p>
</li>
<li><p>tag</p>
<p>可以绑定用户的自定义信息</p>
</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol>
<li><p><code>- (id)init;</code></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">xmppQueueTag = &amp;xmppQueueTag;</span><br><span class="line">xmppQueue = dispatch_queue_create(<span class="string">"xmpp"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 向xmppQueue队列设置标识xmppQueueTag，方便进行当前队列的判断</span></span><br><span class="line">dispatch_queue_set_specific(xmppQueue, xmppQueueTag, xmppQueueTag, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">willSendIqQueue = dispatch_queue_create(<span class="string">"xmpp.willSendIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendMessageQueue = dispatch_queue_create(<span class="string">"xmpp.willSendMessage"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendPresenceQueue = dispatch_queue_create(<span class="string">"xmpp.willSendPresence"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendLoginQueue = dispatch_queue_create(<span class="string">"xmpp.willSendLogin"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">willReceiveIqQueue = dispatch_queue_create(<span class="string">"xmpp.willReceiveIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceiveMessageQueue = dispatch_queue_create(<span class="string">"xmpp.willReceiveMessage"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceivePresenceQueue = dispatch_queue_create(<span class="string">"xmpp.willReceivePresence"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceiveLogin = dispatch_queue_create(<span class="string">"xmpp.willReceiveLogin"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">didReceiveIqQueue = dispatch_queue_create(<span class="string">"xmpp.didReceiveIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 初始化多重委托</span></span><br><span class="line">multicastDelegate = (GCDMulticastDelegate &lt;XMPPStreamDelegate&gt; *)[[GCDMulticastDelegate alloc] init];</span><br><span class="line"></span><br><span class="line">state = STATE_XMPP_DISCONNECTED;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">config = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">numberOfBytesSent = <span class="number">0</span>;</span><br><span class="line">numberOfBytesReceived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">hostPort = <span class="number">5222</span>;</span><br><span class="line"><span class="comment">// 2分钟的心跳数据等待发送间隔</span></span><br><span class="line">keepAliveInterval = DEFAULT_KEEPALIVE_INTERVAL;</span><br><span class="line">keepAliveData = [<span class="string">@" "</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">registeredModules = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">autoDelegateDict = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">receipts = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p> asyncSocket初始化</p>
</li>
<li><p>多重委托相关</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegate:(<span class="keyword">id</span>)delegate delegateQueue:(<span class="built_in">dispatch_queue_t</span>)delegateQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Asynchronous operation (if outside xmppQueue)</span></span><br><span class="line"></span><br><span class="line">dispatch_block_t block = ^&#123;</span><br><span class="line">[multicastDelegate addDelegate:delegate delegateQueue:delegateQueue];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatch_get_specific(xmppQueueTag))<span class="comment">// 当前队列是xmppQueue</span></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 当前队列不是xmppQueue</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(xmppQueue, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<h2 id="连接与断开"><a href="#连接与断开" class="headerlink" title="连接与断开"></a>连接与断开</h2><ol>
<li><p><code>- (BOOL)connectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</code></p>
<p> 通过设定好的hostPort连接hostName:<br> <code>[self connectToHost:hostName onPort:hostPort withTimeout:XMPPStreamTimeoutNone error:&amp;connectErr]</code></p>
<blockquote>
<p>通知代理：<code>[multicastDelegate xmppStreamWillConnect:self];</code></p>
<p>无hostName，则利用用户JID的域名进行服务定位（SRV）资源查找；</p>
<p>有hostName，则与该主机建立TCP连接</p>
<blockquote>
<p><code>[asyncSocket connectToHost:host onPort:port error:errPtr]</code></p>
<p>设置连接超时的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startConnectTimeout:(<span class="built_in">NSTimeInterval</span>)timeout</span><br><span class="line">&#123;</span><br><span class="line">XMPPLogTrace();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt;= <span class="number">0.0</span> &amp;&amp; !connectTimer)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 创建计时器型dispatch source</span></span><br><span class="line">        connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, xmppQueue);</span><br><span class="line">    <span class="comment">// 设置到时后的block：进行连接超时操作</span></span><br><span class="line">        dispatch_source_set_event_handler(connectTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 连接超时操作</span></span><br><span class="line">            [<span class="keyword">self</span> doConnectTimeout];</span><br><span class="line">        &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">        dispatch_source_t theConnectTimer = connectTimer;</span><br><span class="line">        dispatch_source_set_cancel_handler(connectTimer, ^&#123;            </span><br><span class="line">XMPPLogVerbose(<span class="string">@"%@: dispatch_release(connectTimer)"</span>, THIS_FILE);</span><br><span class="line">            dispatch_release(theConnectTimer);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        <span class="comment">// 初始化计时器</span></span><br><span class="line">        dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (timeout * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">        dispatch_source_set_timer(connectTimer, tt, DISPATCH_TIME_FOREVER, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 启动connectTimer</span></span><br><span class="line">        dispatch_resume(connectTimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接成功，将触发<code>(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code>代理中连接超时将会关闭。</p>
</blockquote>
</blockquote>
</li>
<li><p><code>- (BOOL)oldSchoolSecureConnectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</code></p>
<p> 提供给那些需要提早保护连接的老旧服务器（这类服务器的端口一般为5223）。</p>
</li>
<li><p><code>- (BOOL)connectP2PWithSocket:(GCDAsyncSocket *)acceptedSocket error:(NSError **)errPtr</code></p>
<p> 当XMPPStream用initP2P方法初始化后，可以使用给定的socket开始P2P连接。</p>
</li>
<li><p><code>- (void)disconnect</code></p>
<p> 关闭TCP socket连接，由于是同步的，所以会立即发生</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知xmppStreamDelegate委托，用来区分断开的原因是自愿还是连接错误</span></span><br><span class="line">[multicastDelegate xmppStreamWasToldToDisconnect:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">// 有主机名	</span></span><br><span class="line"><span class="keyword">if</span> (state == STATE_XMPP_RESOLVING_SRV)</span><br><span class="line">&#123;<span class="comment">// 停止XMPPSRVResolver</span></span><br><span class="line">[srvResolver stop];</span><br><span class="line">srvResolver = <span class="literal">nil</span>;</span><br><span class="line">state = STATE_XMPP_DISCONNECTED;</span><br><span class="line"><span class="comment">// 通知xmppStreamDelegate委托，</span></span><br><span class="line">[multicastDelegate xmppStreamDidDisconnect:<span class="keyword">self</span> withError:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 断开socket连接</span></span><br><span class="line">[asyncSocket disconnect];</span><br><span class="line"><span class="comment">// Everthing will be handled in socketDidDisconnect:withError:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>- (void)disconnectWithError:(NSError*)error</code></p>
<p> 由于错误而发生的断开，与4相同，不同之处在于通知delegate错误信息。</p>
</li>
</ol>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol>
<li><p>secure</p>
<blockquote>
<p><code>- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code>socket连接成功后触发</p>
<blockquote>
<p><code>[self startTLS]</code></p>
<blockquote>
<p>开始之前通知所有的代理（如果包含(xmppStream:willSecureWithSettings:)方法）</p>
<p><code>[self continueStartTLS:settings]</code></p>
<blockquote>
<p><code>[asyncSocket startTLS:settings];</code>socket开始TLS协商会话</p>
<p>secure设为YES</p>
<p>开始协商</p>
<p>asyncSocket开始读取数据</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><code>- (BOOL)supportsStartTLS()</code></p>
<p> 判断服务器是否可以通过SSL/TLS对连接进行保护</p>
<p> 通过读取rootElement的子元素<starttls>来实现。</starttls></p>
</li>
<li><p><code>- (BOOL)secureConnection:(NSError **)errPtr</code></p>
<p> 企图通过SSL/TLS来保护连接，该方法是同步的，errPtr用于存放错误信息，</p>
<blockquote>
<p><code>[self sendStartTLSRequest]</code></p>
<p>服务器收到请求后发送响应</p>
<blockquote>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadElement:(NSXMLElement *)element</code>接收到带<code>proceed</code>元素</p>
<blockquote>
<p><code>[self handleStartTLSResponse:element]</code></p>
<blockquote>
<p><code>[self startTLS]</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ol>
<li><p><code>- (BOOL)supportsInBandRegistration</code></p>
<p> 查看服务器是否支持带内（in-Band）注册</p>
</li>
<li><p><code>- (BOOL)registerWithElements:(NSArray *)elements error:(NSError **)errPtr;</code></p>
<p> 通过给定的元素进行新用户的注册</p>
<blockquote>
<p>建立<code>type</code>为<code>set</code>的IQ元素</p>
<p>建立<query>的NSXMLElement，将元素数组的元素全部加入进去</query></p>
<p>将<query>放入IQ</query></p>
<p>对xmlString通过压缩，编码，生成 outgoingData</p>
<p><code>[asyncSocket writeData:outgoingData withTimeout:TIMEOUT_XMPP_WRITE tag:TAG_XMPP_WRITE_STREAM]</code></p>
</blockquote>
</li>
<li><p><code>- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr;</code></p>
<p> 通过给定的用户名和密码建立一个用户账号</p>
<p> 将<code>username</code>和<code>password</code>两个元素添加到elements中并调用2的方法进行注册。</p>
</li>
</ol>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p><code>- (BOOL)authenticateWithPassword:(NSString *)inPassword error:(NSError **)errPtr</code></p>
<blockquote>
<p>选择一个最好的认证方法，共四种</p>
<p><code>[self authenticate:someAuth error:&amp;err]</code></p>
<blockquote>
<p><code>state = STATE_XMPP_AUTH</code></p>
<p><code>[inAuth start:&amp;err]</code></p>
<blockquote>
<p><code>- (void)sendAuthElement:(NSXMLElement *)element</code></p>
<blockquote>
<p><code>[asyncSocket writeData:outgoingData withTimeout:TIMEOUT_XMPP_WRITE tag:TAG_XMPP_WRITE_STREAM]</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h2><p>服务器相关信息来自rootElement，每次收到xml消息通过parser进行解析时，都要从头结点开始，就会触发相应的代理。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ol>
<li><p><code>- (void)sendElement:(NSXMLElement *)element</code></p>
<p> 一般情况下iq、message、presence、login都是通过该通用方法进行发送;</p>
<p> 如果element属于以上任何一个类型则使用对应的发送方法；如果不是则根据name通过object_setClass转换为对应类型；如果都不是则将element以压缩字符串的形式直接发送。</p>
</li>
<li><p><code>- (void)sendIQ:(XMPPIQ *)iq withTag:(long)tag</code></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知一切感兴趣的代理，为了能够以线程安全的方式改变元素(element)，需要连续进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取multicastDelegate的枚举，方便遍历</span></span><br><span class="line">GCDMulticastDelegateEnumerator *delegateEnumerator = [multicastDelegate delegateEnumerator];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(willSendIqQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow delegates to modify and/or filter outgoing element</span></span><br><span class="line"></span><br><span class="line">__block XMPPIQ *modifiedIQ = iq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> del;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (modifiedIQ &amp;&amp; [delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 确定代理方法(xmppStream:willSendIQ:)的返回值是否是(XMPPIQ *)</span></span><br><span class="line"><span class="keyword">char</span> methodReturnType[<span class="number">32</span>];</span><br><span class="line">Method method = class_getInstanceMethod([del class], selector);</span><br><span class="line">method_getReturnType(method, methodReturnType, <span class="keyword">sizeof</span>(methodReturnType));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strcmp(methodReturnType, @encode(XMPPIQ*)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"Method xmppStream:willSendIQ: is no longer void (see XMPPStream.h). "</span></span><br><span class="line"><span class="string">@"Culprit = %@"</span>, <span class="built_in">NSStringFromClass</span>([del class]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dq, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">// 提供通过外部delegate改变IQ的机会</span></span><br><span class="line">modifiedIQ = [del xmppStream:<span class="keyword">self</span> willSendIQ:modifiedIQ];</span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (modifiedIQ)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(xmppQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == STATE_XMPP_CONNECTED) &#123;</span><br><span class="line"><span class="comment">// 继续IQ的发送：压缩转码后通过[asyncSocket writeData:...]方法发送</span></span><br><span class="line">[<span class="keyword">self</span> continueSendIQ:modifiedIQ withTag:tag];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>- (void)sendLogin:(XMPPLogin *)login withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)sendMessage:(XMPPMessage *)message withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)sendPresence:(XMPPPresence *)presence withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)injectElement:(NSXMLElement *)element</code></p>
<p> 该方法允许你将一个元素插入到流中，就好像是从socket接收到的消息一样，这创造了一些有趣的可能性。</p>
</li>
</ol>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>接收消息的过程：</p>
<blockquote>
<p>AsyncSocket的代理方法<code>- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</code>接收到数据</p>
<p><code>[parser parseData:data]</code></p>
<blockquote>
<p>触发parser的代理方法</p>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadRoot:(NSXMLElement *)root</code>拿到rootElement</p>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadElement:(NSXMLElement *)element</code>解析element，并根据state的状态分发下去：</p>
<blockquote>
<p><code>STATE_XMPP_NEGOTIATING</code>-&gt;<code>[self handleStreamFeatures]</code></p>
<p>该方法用来分析接收到的服务器的流特征，判断是否已经与服务器建立了连接</p>
<blockquote>
<p>根据features检查是否需要TLS，需要则<code>[self sendStartTLSRequest]</code></p>
<p>根据features检查是否支持资源绑定，需要则将<strong>资源绑定请求</strong>加入到iq中发送到服务器</p>
<p><code>state = STATE_XMPP_CONNECTED</code></p>
</blockquote>
<p><code>STATE_XMPP_STARTTLS_1</code>-&gt;<code>[self handleStartTLSResponse:element]</code></p>
<blockquote>
<p>如果返回的是”proceed”的元素，则成功，开始TLS协商；如果不成功则断开连接。</p>
</blockquote>
<p><code>STATE_XMPP_REGISTERING</code>-&gt;<code>[self handleRegistration:element]</code></p>
<blockquote>
<p>如果返回的元素的<code>type</code>不是”error”，则注册成功。</p>
</blockquote>
<p><code>STATE_XMPP_AUTH</code>-&gt;<code>[self handleAuth:element]</code></p>
<blockquote>
<p>如果认证成功，则再次开始协商。</p>
</blockquote>
<p><code>STATE_XMPP_BINDING)</code>-&gt;<code>[self handleBinding:element]</code></p>
<blockquote>
<p>如果能够拿到JID，说明资源绑定成功，检查是否需要建立对话，需要则开始IM会话，结束。</p>
<p>没有JID则尝试改变resource</p>
<p>通知代理，利用代理方法得到更改后的resource</p>
<p><code>[self continueHandleBinding:alternativeResource]</code></p>
<blockquote>
<p>有<code>alternativeResource</code>则添加到iq中发送</p>
<p>没有则让服务器来分配resource（通过发送<code>type</code>为”set”的iq）</p>
</blockquote>
</blockquote>
<p><code>STATE_XMPP_START_SESSION</code>-&gt;<code>[self handleStartSessionResponse:element]</code></p>
<blockquote>
<p><code>type</code>为”result”表示认证成功，回到<code>STATE_XMPP_CONNECTED</code>状态</p>
</blockquote>
<p><code>iq</code>-&gt;<code>[self receiveIQ:[XMPPIQ iqFromElement:element]]</code></p>
<blockquote>
<p>通知所有的代理，可在解析iq前改变或过滤iq</p>
<p><code>[self continueReceiveIQ:modifiedIQ]</code></p>
<blockquote>
<p>如果iq需要回复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(xmppStream:didReceiveIQ:);</span><br><span class="line"><span class="comment">// 用信号量快速控制并发</span></span><br><span class="line">dispatch_semaphore_t delSemaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">dispatch_group_t delGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ([delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line">dispatch_group_async(delGroup, dq, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([del xmppStream:<span class="keyword">self</span> didReceiveIQ:iq])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 有代理方法对iq进行占用则发送一个信号</span></span><br><span class="line">dispatch_semaphore_signal(delSemaphore);</span><br><span class="line">&#125;	</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(didReceiveIqQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(delGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did any of the delegates handle the IQ? (handle == will response)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> handled = (dispatch_semaphore_wait(delSemaphore, DISPATCH_TIME_NOW) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端收到&lt;type&gt;为"get"或"set"的IQ请求时必须以&lt;type&gt;为"result"或"error"的iq来回复，并且回复的iq必须保留收到的iq的"id"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有代理来处理这个iq则返回带&lt;errro&gt;的iq</span></span><br><span class="line"><span class="keyword">if</span> (!handled)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 返回给服务器的错误信息：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;iq to="jid" type="error" id="id"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;query xmlns="ns"/&gt;</span></span><br><span class="line"><span class="comment">//   &lt;error type="cancel" code="501"&gt;</span></span><br><span class="line"><span class="comment">//     &lt;feature-not-implemented xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"/&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/error&gt;</span></span><br><span class="line"><span class="comment">// &lt;/iq&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSXMLElement</span> *reason = [<span class="built_in">NSXMLElement</span> elementWithName:<span class="string">@"feature-not-implemented"</span></span><br><span class="line">xmlns:<span class="string">@"urn:ietf:params:xml:ns:xmpp-stanzas"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSXMLElement</span> *error = [<span class="built_in">NSXMLElement</span> elementWithName:<span class="string">@"error"</span>];</span><br><span class="line">[error addAttributeWithName:<span class="string">@"type"</span> stringValue:<span class="string">@"cancel"</span>];</span><br><span class="line">[error addAttributeWithName:<span class="string">@"code"</span> stringValue:<span class="string">@"501"</span>];</span><br><span class="line">[error addChild:reason];</span><br><span class="line"></span><br><span class="line">XMPPIQ *iqResponse = [XMPPIQ iqWithType:<span class="string">@"error"</span></span><br><span class="line">to:[iq from]</span><br><span class="line">elementID:[iq elementID]</span><br><span class="line">child:error];</span><br><span class="line"><span class="comment">// 返回的iq中添加iq的子元素		</span></span><br><span class="line"><span class="built_in">NSXMLElement</span> *iqChild = [iq childElement];</span><br><span class="line"><span class="keyword">if</span> (iqChild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSXMLNode</span> *iqChildCopy = [iqChild <span class="keyword">copy</span>];</span><br><span class="line">[iqResponse insertChild:iqChildCopy atIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Purposefully go through the sendElement: method</span></span><br><span class="line"><span class="comment">// so that it gets dispatched onto the xmppQueue,</span></span><br><span class="line"><span class="comment">// and so that modules may get notified of the outgoing error message.</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> sendElement:iqResponse];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">dispatch_release(delSemaphore);</span><br><span class="line">dispatch_release(delGroup);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p><code>message</code>-&gt;<code>[self receiveMessage:[XMPPMessage messageFromElement:element]]</code></p>
<p><code>presence</code>-&gt;<code>[self receivePresence:[XMPPPresence presenceFromElement:element]]</code></p>
<p><code>cmcc_client_login</code>-&gt;<code>[self receiveLogin:[XMPPLogin loginFromElement:element]]</code></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="流协商"><a href="#流协商" class="headerlink" title="流协商"></a>流协商</h2><ol>
<li><p><code>- (void)startNegotiation</code></p>
<p> 用来开始初始的协商操作</p>
<blockquote>
<p><code>[self sendOpeningNegotiation]</code>初始化XML流</p>
<blockquote>
<p>通过socket发送&lt;?xml version=’1.0’?&gt;，</p>
<p>初始化或重启parser，从而将self赋值给parser的代理，从而可以在XMPPStream中实现parser的代理方法。</p>
<p>发送<stream:stream xmlns="%@" xmlns:stream="%@" version="1.0" to="%@"></stream:stream></p>
</blockquote>
<p><code>[multicastDelegate xmppStreamDidStartNegotiation:self]</code></p>
<p><code>[asyncSocket readDataWithTimeout:TIMEOUT_XMPP_READ_START tag:TAG_XMPP_READ_START]</code></p>
</blockquote>
</li>
<li><p><code>- (void)startTLS</code></p>
<p> 根据正确的设置，开始TLS协商，在”安全”章节中有提到。</p>
</li>
</ol>
<h2 id="心跳数据"><a href="#心跳数据" class="headerlink" title="心跳数据"></a>心跳数据</h2><p><code>- (void)setupKeepAliveTimer</code>设置心跳数据计时器</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">keepAliveTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, xmppQueue);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(keepAliveTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">// 发送心跳数据	</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line"><span class="built_in">NSTimeInterval</span> elapsed = (now - lastSendReceiveTime);</span><br><span class="line"><span class="comment">// 如果长达2分钟没有通信发生则发送心跳数据</span></span><br><span class="line"><span class="keyword">if</span> (elapsed &lt; <span class="number">0</span> || elapsed &gt;= keepAliveInterval)</span><br><span class="line">&#123;</span><br><span class="line">numberOfBytesSent += [keepAliveData length];</span><br><span class="line"></span><br><span class="line">[asyncSocket writeData:keepAliveData</span><br><span class="line">withTimeout:TIMEOUT_XMPP_WRITE</span><br><span class="line">tag:TAG_XMPP_WRITE_STREAM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制更新	lastSendReceiveTime，以防TCP socket通信由于传送巨大而缓慢	</span></span><br><span class="line">lastSendReceiveTime = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">uint64_t interval = ((keepAliveInterval / <span class="number">4.0</span>) * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">// 设置计时器的开始时间-延时30s</span></span><br><span class="line">dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, interval);</span><br><span class="line"><span class="comment">// 以30s为间隔发送心跳数据</span></span><br><span class="line">dispatch_source_set_timer(keepAliveTimer, tt, interval, <span class="number">1.0</span>);</span><br><span class="line">dispatch_resume(keepAliveTimer);</span><br></pre></td></tr></table></figure>
<h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ol>
<li><p>AsyncSocket</p>
<ul>
<li><p><code>- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code></p>
<blockquote>
<p><code>[self endConnectTimeout]</code>取消超时处理</p>
<p><code>[asyncSocket enableBackgroundingOnSocket]</code>开启socket的后台监听</p>
<p><code>[self startTLS]</code></p>
<p><code>[self startNegotiation]</code></p>
</blockquote>
</li>
<li><p><code>- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</code></p>
<blockquote>
<p><code>[parser parseData:data]</code></p>
<p><code>[asyncSocket readDataWithTimeout:TIMEOUT_XMPP_READ_STREAM tag:TAG_XMPP_READ_STREAM]</code>继续读取xml元素</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>从中可以看出，XMPPStream是一个设计严谨，线程安全的消息通讯类型，其风格包括：</p>
<ol>
<li>为了保证线程安全：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t block = ^&#123;</span><br><span class="line"><span class="comment">// 要在xmpp线程中运行的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (dispatch_get_specific(xmppQueueTag))</span><br><span class="line">block();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(xmppQueue, block);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<ol>
<li>如何通知带返回值的代理方法<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(对应的代理方法)</span><br><span class="line"><span class="keyword">if</span> (![multicastDelegate hasDelegateThatRespondsToSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// None of the delegates implement the method.</span></span><br><span class="line"><span class="comment">// Use a shortcut.</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">GCDMulticastDelegateEnumerator *delegateEnumerator = [multicastDelegate delegateEnumerator];</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ([delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dq, ^&#123;<span class="keyword">@autoreleasepool</span></span><br><span class="line">&#123;</span><br><span class="line">[del 对应的代理方法];</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记:"></a>后记:</h2><p>本文只是在看源代码过程中对个人简介的一点梳理，由于能力所限，无论排版还是内容理解都有所欠缺，如有错误还请见谅，该文以后还会改进与更新。<br>下一篇文章为多重代理的原理与实现，敬请期待。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XMPPFramework源码分析<二> - JID]]></title>
      <url>http://xenobladex.github.io/2016/05/19/XMPPFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-JID/</url>
      <content type="html"><![CDATA[<p>XMPP的地址叫做JabberID（简写为JID），用来标示XMPP网络中的各个XMPP实体。JID有三个属性：domain，node identifier和resource，其中domain是必不可少的部分。（注意：domain和user部分是不分大小写的，但是resource区分大小写。）</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>user</p>
<p> 通常表示一个向服务器或网关请求和使用网络服务的实体(比如一个客户端),当然它也能够表示其他的实体(比如在多用户聊天系统中的一个房间)。</p>
</li>
<li><p>domain</p>
<p> 通常指网络中的网关或者服务器。</p>
</li>
<li><p>resource</p>
<p> 通常表示一个特定的会话（与某个设备），连接（与某个地址），或者一个附属于某个节点ID实体相关实体的对象（比如多用户聊天室中的一个参加者）。</p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>+ (XMPPJID *)jidWithString:(NSString *)jidStr</code></p>
<p>  根据JID的组成规则，从JID字符串中生成JID模型。</p>
<ol>
<li><p><code>+ (BOOL)parse:(NSString *)jidStr outUser:(NSString **)user outDomain:(NSString **)domain outResource:(NSString **)resource</code></p>
<p> 从字符串中分割出user、domain与resource。</p>
<blockquote>
<p>JID字符串的规则为[node”@”]domain[“/“resource]，所以查找”@”与”/“的<code>NSRange</code></p>
<blockquote>
<p>获得user、domain、resource，小写转换</p>
<blockquote>
<p>判断domain不包含”@””，resource不再包含”/“</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>copy</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><code>- (BOOL)isEqualToJID:(XMPPJID *)aJID options:(XMPPJIDCompareOptions)mask</code></p>
<p>  该方法判断两个JID是否相同，mask限定比较的范围。比常用的<code>isEqual:</code>方法要快（<code>isEqual:</code>是NSObject的方法，比较的是hash返回的值）。</p>
<p>  三个属性分别进行字符串内容比较<code>isEqualToString :</code></p>
<blockquote>
<p>题外话：XMPPJID实现了<code>- (NSUInteger)hash</code>，利用MurmurHash2库，将3个属性字符串的hash值合并。所以JID可以直接进行<code>isEqual:</code>比较。</p>
</blockquote>
</li>
</ul>
<p>​</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《<a href="http://blog.csdn.net/wbw1985/article/details/5502272" target="_blank" rel="external">XMPP协议的原理介绍</a>》</p>
<p>《<a href="http://www.cnphp6.com/archives/25578" target="_blank" rel="external">XMPP JID 和通信原语有3种：MESSAGE、PRESENCE和IQ</a>》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XMPPFramework源码分析<一> - 消息]]></title>
      <url>http://xenobladex.github.io/2016/05/19/XMPPFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-%E6%B6%88%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>XMPPFramework所有的消息都是以xml的形式通过XMPPStream传递，数据的解析和包装都是基于xml文件操作，这里消息又被细分为了Message、Presence、IQ。</p>
<h2 id="XMPPElement"><a href="#XMPPElement" class="headerlink" title="XMPPElement"></a>XMPPElement</h2><p>XMPPElement是XMPP三大消息类型Message、Presence、IQ的基类，继承自NSXMLElement，值得注意的是在ios平台上采用更加高效的KissXML来代替NSXMLElement进行xml的解析。</p>
<h3 id="协议实现："><a href="#协议实现：" class="headerlink" title="协议实现："></a>协议实现：</h3><ol>
<li><p><code>- (id)initWithCoder:(NSCoder *)coder</code></p>
<p> NSCoding协议</p>
<blockquote>
<p>用<code>[coder decodeObjectForKey:@&quot;xmlString&quot;]</code>解码成xml字符串</p>
<blockquote>
<p>用XMPPElement的<code>initWithXMLString:</code>转换成XMPPElement类型</p>
<blockquote>
<p><code>object_setClass</code>将XMPPElement类型转换为XMPPElement类型</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><code>- (void)encodeWithCoder:(NSCoder *)coder</code></p>
<p> NSCoding协议</p>
<blockquote>
<p>调用<code>compactXMLString</code>将XMPPElement转化为压缩型xml字符串</p>
<blockquote>
<p>调用NSXMLElement的<code>encodeObject</code>对xml字符串进行编码</p>
</blockquote>
</blockquote>
</li>
<li><p><code>- (id)copyWithZone:(NSZone *)zone</code></p>
<p> NSCopy协议，由于XMPPElement继承自NSXMLElement，所以获得NSXMLElement类型的copy后，用<code>object_setClass</code>运行时将此备份转换为XMPPElement类型。</p>
</li>
</ol>
<h3 id="公开接口："><a href="#公开接口：" class="headerlink" title="公开接口："></a>公开接口：</h3><ol>
<li>Jabber通信中常用的<strong>属性方法</strong>，包括elementID、to、from、guid、toStr、fromStr、guidStr、timeStr，通过XML解析相应元素的方式来提供。<ul>
<li>elementID：元素id</li>
<li>to：解析后的收件人JID模型（从toStr生成）</li>
<li>from：解析后的发件人JID模型（从fromStr生成）</li>
<li>guid：全局唯一标志符</li>
<li>toStr：发件人JID字符串</li>
<li>fromStr：收件人JID字符串</li>
<li>guidStr：guid字符串</li>
<li>timeStr：发送时间字符串</li>
</ul>
</li>
<li>判断to或from是否相同的方法</li>
</ol>
<h2 id="XMPPMessage"><a href="#XMPPMessage" class="headerlink" title="XMPPMessage"></a>XMPPMessage</h2><p>message是一种基于<strong>推送消息</strong>方法，以<message>作为元素，它不要求响应。主要用于IM、groupChat、alert和notification之类的应用中。</message></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p><code>+ (XMPPMessage *)messageFromElement:(NSXMLElement *)element</code></p>
<p> 将NSXMLElement对象替换成XMPPMessage实例</p>
<p> 依然使用<code>object_setClass</code></p>
</li>
<li><p><code>- (id)initWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement</code></p>
<blockquote>
<p>以”message”初始化XML元素</p>
<blockquote>
<p>添加type、to、id属性</p>
<blockquote>
<p>插入子元素</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li><p>属性：type</p>
<ul>
<li>normal：类似于email，主要特点是不要求响应；</li>
<li>chat：类似于qq里的好友即时聊天，主要特点是实时通讯；</li>
<li>groupchat：类似于聊天室里的群聊；</li>
<li>headline：用于发送alert和notification；</li>
<li>error：如果发送message出错，发现错误的实体会用这个类别来通知发送者出错了；</li>
</ul>
</li>
<li><p>内容</p>
<p> body、subject、bodyForlanguage、thread</p>
</li>
<li><p>添加子元素</p>
<ul>
<li><code>- (void)addSubject:(NSString *)subject</code></li>
<li><code>- (void)addBody:(NSString *)body</code></li>
<li><code>- (void)addBody:(NSString *)body withLanguage:(NSString *)language</code></li>
<li><code>- (void)addThread:(NSString *)thread</code></li>
</ul>
</li>
<li><p>类型判断</p>
</li>
</ol>
<p>​</p>
<h2 id="XMPPPresence"><a href="#XMPPPresence" class="headerlink" title="XMPPPresence"></a>XMPPPresence</h2><p>presence用来表明<strong>用户的状态</strong>，如：online、away、dnd(请勿打扰)等。要想接受presence消息，必须经过一个叫做presence subscription的授权过程。 </p>
<h3 id="属性：type"><a href="#属性：type" class="headerlink" title="属性：type"></a>属性：type</h3><ul>
<li>subscribe：订阅其他用户的状态</li>
<li>probe：请求获取其他用户的状态</li>
<li>unavailable：不可用，离线（offline）状态</li>
</ul>
<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><ol>
<li><p>show：</p>
<ol>
<li>chat：聊天中</li>
<li>away：暂时离开</li>
<li>xa：extend Away，长时间离开</li>
<li>dnd：勿打扰</li>
</ol>
</li>
<li><p>status：</p>
<p> 格式自由，可阅读的文本。也叫做rich presence或者extended presence，常用来表示用户当前心情，活动，听的歌曲，看的视频，所在的聊天室，访问的网页，玩的游戏等。</p>
</li>
<li><p>priority：</p>
<p> 范围-128~127。高优先级的resource能接受发送到bare JID的消息，低优先级的resource不能。优先级为负数的resource不能收到发送到bare JID的消息。</p>
</li>
</ol>
<h2 id="XMPPIQ"><a href="#XMPPIQ" class="headerlink" title="XMPPIQ"></a>XMPPIQ</h2><p>一种<strong>请求／响应机制</strong>，从一个实体发送请求，另外一个实体接受请求，并进行响应。例如，client在stream的上下文中插入一个元素，向Server请求得到自己的好友列表，Server返回一个，里面是请求的结果。 </p>
<h3 id="属性：type-1"><a href="#属性：type-1" class="headerlink" title="属性：type"></a>属性：type</h3><ul>
<li>Get :获取当前域值。类似于http get方法。</li>
</ul>
<ul>
<li>Set :设置或替换get查询的值。类似于http post方法。</li>
</ul>
<ul>
<li>Result :说明成功的响应了先前的查询。类似于http状态码200。</li>
<li>Error: 查询和响应中出现的错误。</li>
</ul>
<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ol>
<li><p><code>- (NSXMLElement *)childElement</code></p>
<p> 获取单个非错误信息的元素</p>
</li>
<li><p><code>- (NSXMLElement *)childErrorElement</code></p>
<p> 获取错误信息的元素</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《<a href="http://blog.csdn.net/wbw1985/article/details/5502272" target="_blank" rel="external">XMPP协议的原理介绍</a>》</p>
<p>《<a href="http://www.cnphp6.com/archives/25578" target="_blank" rel="external">XMPP JID 和通信原语有3种：MESSAGE、PRESENCE和IQ</a>》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多重委托(MultiDelegate)官方解释]]></title>
      <url>http://xenobladex.github.io/2016/05/18/%E5%A4%9A%E9%87%8D%E5%A7%94%E6%89%98-MultiDelegate-%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>该文档回答了这几个问题：(1)什么是多重委托？(2)使用的原因。(3)为什么不使用普通的委托与通知？</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr>
<p>苹果有两种常用的回调方式：</p>
<ul>
<li>委托</li>
<li>通知<br>委托非常简单和直接，用户注册自己为一个委托，然后实现它需要去实现的方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[worker setDelegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)wokerDidFinish:(Worker *)sender</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)woker:(Worker *)sender didFinishSubTask:(<span class="keyword">id</span>)subtask inDuration:(NsTimeInterval)elapsed</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">BOOL</span>)worker:(Worker *)sender shouldPerformSubTask:(<span class="keyword">id</span>)subtask</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知同样简单，但是需要多了几步，用户需要分别注册它们感兴趣的每个通知：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">selector:<span class="keyword">@selector</span>(workerDidFinish:)</span><br><span class="line">name:WorkerDidFinishNotification</span><br><span class="line">object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">selector:<span class="keyword">@selector</span>(workerDidFinishSubTask:)</span><br><span class="line">name:WorkerDidFinishSubTaskNotification</span><br><span class="line">object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)workerDidFinish:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">Worker *sender = [notification object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)workerDidFinishSubTask:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">Worker *sender = [notification object];</span><br><span class="line"><span class="keyword">id</span> subtask = [[notification userInfo] objectForKey:<span class="string">@"subtask"</span>];</span><br><span class="line"><span class="built_in">NSTimeInterval</span> elapsed = [[[notification userInfo] objectForKey<span class="string">"duration"</span>] doubleValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们要将参数从通知字典中取出，也就是说用户需要知道正确的键值才能取出对应的参数。<br>另外第三方委托方法不能通过通知来实现，因为<strong>通知不允许返回变量</strong>。<br>Delegate的缺点：</p>
<ul>
<li>只能有一个委托<br>notification的缺点：</li>
<li>注册多个回调时比较麻烦</li>
<li>从字典中取出参数非常麻烦</li>
<li>当需要返回值时无法使用<h2 id="XMPP框架需要哪些东西？"><a href="#XMPP框架需要哪些东西？" class="headerlink" title="XMPP框架需要哪些东西？"></a>XMPP框架需要哪些东西？</h2></li>
</ul>
<hr>
<ol>
<li>xmpp框架必须能够把事件广播给多个接收者。<br>以消息为例，可能存在多个接收端：聊天窗口，历史日志以及消息推送系统。</li>
<li>xmpp框架必须易于扩展。<br>它必须能够支持大量的EXP’s以及任何想进行二次开发的xmpp协议的开发者，我们选择的解决方案必须在传播端和接收端都易于使用。</li>
<li>必须支持返回值。<br>一个不错的例子是XMPP RFC的IQ处理授权。如果一个客户端接收到一个类型为’get’或’set’的IQ，但是不知道该怎么处理时，它必须返回一个类型为’error’的IQ，这在多插件时非常有用。</li>
<li>必须有效维持线程安全。<br>xmpp框架存在大量并行，Socket接口、xml解析、xmpp、模块、磁盘接口以及委托都能够运行在他们自己的GCD队列中，这在多核设备中意味着许多任务同时运行在不同的线程中，系统不应该通过跳出循环来维持线程安全。</li>
</ol>
<p>从这些看来委托和通知都不能很好的满足我们的要求，所以我们设计了<code>GCDMulticastDelegate</code>类。</p>
<h2 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h2><hr>
<p>它非常简单，作为客户端，你只要这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add myself as a delegate, and tell xmppStream to invoke my delegate methods on the main thread</span></span><br><span class="line">[xmppStream addDelegate:<span class="keyword">self</span> delegateQueue:dispatch_get_main_queue()];</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Then just implement whatever delegate methods you need like normal</span></span><br><span class="line">-(<span class="keyword">void</span>)smppStream:(XMPPStream *)sender didReciveMessage:(XMPPMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这些，你可以看到，它和普通的委托非常相似，但是允许你指定特定线程。<br>如果之后你决定把你的操作移出主线程的话，同样非常简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handle most stuff on the main thread</span></span><br><span class="line">[xmppStream addDelegate:<span class="keyword">self</span> delegateQueue:dispatch_get_main_queue()];</span><br><span class="line"><span class="comment">//But do that one slow thing on a background queue so it doesn't slow down the UI anymore</span></span><br><span class="line">[xmppSream addDelegate:bgProcessor delegateQueue:bgProcessorQueue];</span><br></pre></td></tr></table></figure>
<p>在IPhone这样的设备环境下，这样做可以很好的维持你应用的性能。</p>
<h2 id="如何在自己的插件中使用"><a href="#如何在自己的插件中使用" class="headerlink" title="如何在自己的插件中使用"></a>如何在自己的插件中使用</h2><hr>
<p>为了使用多重委托，作为广播端，你需要申明并初始化它：<br>GCDMulticastDelegate <myplugindelegate> <em>multicastDelegate;<br>multicastDelegate = (GCDMulticastDelegate <myplugindelegate> </myplugindelegate></em>)[[GCDMulticastDelegate alloc] init];<br>然后添加能够允许其他对象从委托列表中添加/删除委托的方法：</myplugindelegate></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)addDelegate:(<span class="keyword">id</span>)delegate delegateQueue:(<span class="built_in">dispatch_queue_t</span>)delegateQueue</span><br><span class="line">&#123;</span><br><span class="line">[multicastDelegate addDelegate:delegate delegateQueue:delegateQueue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)removeDelegate:(<span class="keyword">id</span>)delegate delegateQueue:(<span class="built_in">dispatch_queue_t</span>)delegateQueue</span><br><span class="line">&#123;</span><br><span class="line">[multicastDelegate removeDelegate:delelgate delegateQueue:delegateQueue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你要触发某个委托方法时，只要是注册了的委托，你可以：<br>[multicastDelegate worker:self didFinishSubTask:subtask inDyration:elapsed];</p>
<h2 id="关于返回变量"><a href="#关于返回变量" class="headerlink" title="关于返回变量"></a>关于返回变量</h2><hr>
<p>对于下面的这个委托方法：<br>-(BOOL)worker:(Worker *)sender shouldPerformSubTask:(id)subtask;</p>
<p>假如返回了三个委托，两个返回YES另一个返回NO，那如何处理它？<br>一般来说，如果任何一个委托返回NO，那我们就不能执行这个任务。<br>那么如何实现它？</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delegate rules:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// If ANY of the delegates return NO, then the result is NO.</span></span><br><span class="line"><span class="comment">// Otherwise the result is YES.</span></span><br><span class="line"></span><br><span class="line">SEL selector = <span class="keyword">@selector</span>(worker:shouldPerformSubTask:);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> delegateCount = [multicastDelegate countForSelector:selector];</span><br><span class="line"><span class="keyword">if</span> (delegateCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// No delegates implement the selector - default is YES</span></span><br><span class="line">[<span class="keyword">self</span> continuePerformSubTask:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Query the delegate(s)</span></span><br><span class="line">GCDMulticastDelegateEnumerator *delegateEnumerator = [multicastDelegate delegateEnumerator];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t delSemaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">dispatch_group_t delGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> del;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ([delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line">dispatch_group_async(delGroup, dq, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![del worker:<span class="keyword">self</span> shouldPerformSubTask:subtask])</span><br><span class="line">&#123;</span><br><span class="line">dispatch_semaphore_signal(delSemaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the delegates to finish</span></span><br><span class="line">dispatch_group_wait(delGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// What was the delegate response?</span></span><br><span class="line"><span class="built_in">BOOL</span> shouldPerformSubTask = (dispatch_semaphore_wait(delSemaphore, DISPATCH_TIME_NOW) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(ourQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">[<span class="keyword">self</span> continuePerformSubTask:shouldPerformSubTask];</span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(delSemaphore);</span><br><span class="line">dispatch_release(delGroup);</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://xenobladex.github.io/2016/05/18/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
