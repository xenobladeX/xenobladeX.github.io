<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This is Ding Ming's Blog on GitHub"><title>XMPPFramework源码分析&lt;三&gt; - 流 | The Zohar</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">XMPPFramework源码分析&lt;三&gt; - 流</h1><a id="logo" href="/.">The Zohar</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">XMPPFramework源码分析&lt;三&gt; - 流</h1><div class="post-meta">May 31, 2016<span> | </span><span class="category"><a href="/categories/IOS/">IOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/05/31/XMPPFramework源码分析-三-流/" href="/2016/05/31/XMPPFramework源码分析-三-流/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#私有成员"><span class="toc-number">1.</span> <span class="toc-text">私有成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-number">2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-number">3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接与断开"><span class="toc-number">4.</span> <span class="toc-text">连接与断开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全"><span class="toc-number">5.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册"><span class="toc-number">6.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#认证"><span class="toc-number">7.</span> <span class="toc-text">认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器信息"><span class="toc-number">8.</span> <span class="toc-text">服务器信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送消息"><span class="toc-number">9.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收消息"><span class="toc-number">10.</span> <span class="toc-text">接收消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流协商"><span class="toc-number">11.</span> <span class="toc-text">流协商</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#心跳数据"><span class="toc-number">12.</span> <span class="toc-text">心跳数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理方法"><span class="toc-number">13.</span> <span class="toc-text">代理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">14.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-number">15.</span> <span class="toc-text">后记:</span></a></li></ol></div></div><div class="post-content"><p>XMPPStream是XMPPFramework的<strong>核心</strong>，所有的消息的发送和接收都是在XMPPStream中进行的。借助CocoaAsyncSocket实现socket通信，申明了GCDAsyncSocketDelegate委托。</p>
<h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><ol>
<li>xmppQueue：线程队列</li>
<li>xmppQueueTag: 线程队列的标志符，用来找回标注过的线程</li>
<li>线程队列：willSendIqQueue、willSendMessageQueue、willSendPresenceQueue、willSendLoginQueue、willReceiveIqQueue、willReceiveMessageQueue、willReceivePresenceQueue、willReceiveLogin、didReceiveIqQueue</li>
<li>connectTimer：监视某些类型事件的对象</li>
<li>multicastDelegate：多重委托</li>
<li>state：枚举XMPPStreamState，表示连接状态</li>
<li>asyncSocket：GCDAsyncSocket的实例，负责socket的连接</li>
<li>parser：XMPPParser实例，负责处理接收到的流。</li>
<li>parserError</li>
<li>flags<ul>
<li>kP2PInitiator：P2P模式</li>
<li>kIsSecure：通过SSL/TLS保护连接</li>
<li>kIsAuthenticated：认证成功</li>
<li>kDidStartNegotiation：Negotiation已经至少开始了一次</li>
</ul>
</li>
<li>config<ul>
<li>kP2PMode：XMPPStream以P2P模式初始化</li>
<li>kResetByteCountPerConnection：字节计数每次连接都会清空</li>
<li>kEnableBackgroundingOnSocket：socket上设置为VOIP标志</li>
</ul>
</li>
<li>authenticationDate</li>
<li>myJID_setByClient：客户端设置的用户JID</li>
<li>myJID_setByServer：服务器设置的用户JID</li>
<li>remoteJID：</li>
<li>rootElement：接收到消息的根元素，包含服务器的配置信息。</li>
<li>lastSendReceiveTime：最近的socket通信时间</li>
<li>keepAliveData：心跳数据，可通过<code>(void)setKeepAliveWhitespaceCharacter:(char)keepAliveChar</code>来改变</li>
<li>registeredModules</li>
<li>autoDelegateDict</li>
<li>srvResolver：XMPPSRVResolver</li>
<li>srvResults：</li>
<li>srvResultsIndex</li>
<li>receipts</li>
<li>userTag</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在对属性赋值和取值时均要判断当前进程是否处在xmppQueue队列下：</p>
<ol>
<li><p>hostName（可选）</p>
<p> 建立TCP连接的服务器主机名，如果没有设置，则进行SRV查找</p>
</li>
<li><p>hostPort</p>
<p> xmpp服务器的端口，默认为5222</p>
</li>
<li><p>autoStartTLS</p>
<p> 是否开启安全传输层协议（TLS），默认为NO</p>
</li>
<li><p>myJID</p>
<p> 用户的JID，当连接时，JID的域名被用来确定xmpp虚拟主机；</p>
<p> 在注册和认证时可以利用用户名生成的JID进行通信。</p>
</li>
<li><p>remoteJID（只用于P2P）</p>
</li>
<li><p>keepAliveInterval：传送心跳数据的无连接时间间隔</p>
<p> xmpp支持传送心跳数据，传送的空白字符会被xmpp协议忽略，该数据只有在没有其他数据传送或接收时发送，当其他数据最后一次发送或接收时，开始计时，并在达到间隔时间时传送数据。</p>
</li>
<li><p>keepAliveWhitespaceCharacter</p>
<p> 可以设定心跳数据的字符串，只能是空格、Tab、回车</p>
</li>
<li><p>myPresence</p>
<p> myJID最近一次发送的presence元素</p>
</li>
<li><p>numberOfBytesSent/numberOfBytesReceived</p>
<p> 通过xmppStream接收或发送的总字节数</p>
</li>
<li><p>resetByteCountPerConnection</p>
<p>是否在新建连接前清空字节统计</p>
</li>
<li><p>tag</p>
<p>可以绑定用户的自定义信息</p>
</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol>
<li><p><code>- (id)init;</code></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">xmppQueueTag = &amp;xmppQueueTag;</span><br><span class="line">xmppQueue = dispatch_queue_create(<span class="string">"xmpp"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 向xmppQueue队列设置标识xmppQueueTag，方便进行当前队列的判断</span></span><br><span class="line">dispatch_queue_set_specific(xmppQueue, xmppQueueTag, xmppQueueTag, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">willSendIqQueue = dispatch_queue_create(<span class="string">"xmpp.willSendIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendMessageQueue = dispatch_queue_create(<span class="string">"xmpp.willSendMessage"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendPresenceQueue = dispatch_queue_create(<span class="string">"xmpp.willSendPresence"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willSendLoginQueue = dispatch_queue_create(<span class="string">"xmpp.willSendLogin"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">willReceiveIqQueue = dispatch_queue_create(<span class="string">"xmpp.willReceiveIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceiveMessageQueue = dispatch_queue_create(<span class="string">"xmpp.willReceiveMessage"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceivePresenceQueue = dispatch_queue_create(<span class="string">"xmpp.willReceivePresence"</span>, <span class="literal">NULL</span>);</span><br><span class="line">willReceiveLogin = dispatch_queue_create(<span class="string">"xmpp.willReceiveLogin"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">didReceiveIqQueue = dispatch_queue_create(<span class="string">"xmpp.didReceiveIq"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 初始化多重委托</span></span><br><span class="line">multicastDelegate = (GCDMulticastDelegate &lt;XMPPStreamDelegate&gt; *)[[GCDMulticastDelegate alloc] init];</span><br><span class="line"></span><br><span class="line">state = STATE_XMPP_DISCONNECTED;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line">config = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">numberOfBytesSent = <span class="number">0</span>;</span><br><span class="line">numberOfBytesReceived = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">hostPort = <span class="number">5222</span>;</span><br><span class="line"><span class="comment">// 2分钟的心跳数据等待发送间隔</span></span><br><span class="line">keepAliveInterval = DEFAULT_KEEPALIVE_INTERVAL;</span><br><span class="line">keepAliveData = [<span class="string">@" "</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">registeredModules = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">autoDelegateDict = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">receipts = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p> asyncSocket初始化</p>
</li>
<li><p>多重委托相关</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegate:(<span class="keyword">id</span>)delegate delegateQueue:(<span class="built_in">dispatch_queue_t</span>)delegateQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Asynchronous operation (if outside xmppQueue)</span></span><br><span class="line"></span><br><span class="line">dispatch_block_t block = ^&#123;</span><br><span class="line">[multicastDelegate addDelegate:delegate delegateQueue:delegateQueue];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatch_get_specific(xmppQueueTag))<span class="comment">// 当前队列是xmppQueue</span></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 当前队列不是xmppQueue</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(xmppQueue, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<h2 id="连接与断开"><a href="#连接与断开" class="headerlink" title="连接与断开"></a>连接与断开</h2><ol>
<li><p><code>- (BOOL)connectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</code></p>
<p> 通过设定好的hostPort连接hostName:<br> <code>[self connectToHost:hostName onPort:hostPort withTimeout:XMPPStreamTimeoutNone error:&amp;connectErr]</code></p>
<blockquote>
<p>通知代理：<code>[multicastDelegate xmppStreamWillConnect:self];</code></p>
<p>无hostName，则利用用户JID的域名进行服务定位（SRV）资源查找；</p>
<p>有hostName，则与该主机建立TCP连接</p>
<blockquote>
<p><code>[asyncSocket connectToHost:host onPort:port error:errPtr]</code></p>
<p>设置连接超时的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startConnectTimeout:(<span class="built_in">NSTimeInterval</span>)timeout</span><br><span class="line">&#123;</span><br><span class="line">XMPPLogTrace();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt;= <span class="number">0.0</span> &amp;&amp; !connectTimer)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 创建计时器型dispatch source</span></span><br><span class="line">        connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, xmppQueue);</span><br><span class="line">    <span class="comment">// 设置到时后的block：进行连接超时操作</span></span><br><span class="line">        dispatch_source_set_event_handler(connectTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 连接超时操作</span></span><br><span class="line">            [<span class="keyword">self</span> doConnectTimeout];</span><br><span class="line">        &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">        dispatch_source_t theConnectTimer = connectTimer;</span><br><span class="line">        dispatch_source_set_cancel_handler(connectTimer, ^&#123;            </span><br><span class="line">XMPPLogVerbose(<span class="string">@"%@: dispatch_release(connectTimer)"</span>, THIS_FILE);</span><br><span class="line">            dispatch_release(theConnectTimer);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        <span class="comment">// 初始化计时器</span></span><br><span class="line">        dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (timeout * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">        dispatch_source_set_timer(connectTimer, tt, DISPATCH_TIME_FOREVER, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 启动connectTimer</span></span><br><span class="line">        dispatch_resume(connectTimer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接成功，将触发<code>(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code>代理中连接超时将会关闭。</p>
</blockquote>
</blockquote>
</li>
<li><p><code>- (BOOL)oldSchoolSecureConnectWithTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</code></p>
<p> 提供给那些需要提早保护连接的老旧服务器（这类服务器的端口一般为5223）。</p>
</li>
<li><p><code>- (BOOL)connectP2PWithSocket:(GCDAsyncSocket *)acceptedSocket error:(NSError **)errPtr</code></p>
<p> 当XMPPStream用initP2P方法初始化后，可以使用给定的socket开始P2P连接。</p>
</li>
<li><p><code>- (void)disconnect</code></p>
<p> 关闭TCP socket连接，由于是同步的，所以会立即发生</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知xmppStreamDelegate委托，用来区分断开的原因是自愿还是连接错误</span></span><br><span class="line">[multicastDelegate xmppStreamWasToldToDisconnect:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">// 有主机名	</span></span><br><span class="line"><span class="keyword">if</span> (state == STATE_XMPP_RESOLVING_SRV)</span><br><span class="line">&#123;<span class="comment">// 停止XMPPSRVResolver</span></span><br><span class="line">[srvResolver stop];</span><br><span class="line">srvResolver = <span class="literal">nil</span>;</span><br><span class="line">state = STATE_XMPP_DISCONNECTED;</span><br><span class="line"><span class="comment">// 通知xmppStreamDelegate委托，</span></span><br><span class="line">[multicastDelegate xmppStreamDidDisconnect:<span class="keyword">self</span> withError:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 断开socket连接</span></span><br><span class="line">[asyncSocket disconnect];</span><br><span class="line"><span class="comment">// Everthing will be handled in socketDidDisconnect:withError:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>- (void)disconnectWithError:(NSError*)error</code></p>
<p> 由于错误而发生的断开，与4相同，不同之处在于通知delegate错误信息。</p>
</li>
</ol>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol>
<li><p>secure</p>
<blockquote>
<p><code>- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code>socket连接成功后触发</p>
<blockquote>
<p><code>[self startTLS]</code></p>
<blockquote>
<p>开始之前通知所有的代理（如果包含(xmppStream:willSecureWithSettings:)方法）</p>
<p><code>[self continueStartTLS:settings]</code></p>
<blockquote>
<p><code>[asyncSocket startTLS:settings];</code>socket开始TLS协商会话</p>
<p>secure设为YES</p>
<p>开始协商</p>
<p>asyncSocket开始读取数据</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p><code>- (BOOL)supportsStartTLS()</code></p>
<p> 判断服务器是否可以通过SSL/TLS对连接进行保护</p>
<p> 通过读取rootElement的子元素<starttls>来实现。</starttls></p>
</li>
<li><p><code>- (BOOL)secureConnection:(NSError **)errPtr</code></p>
<p> 企图通过SSL/TLS来保护连接，该方法是同步的，errPtr用于存放错误信息，</p>
<blockquote>
<p><code>[self sendStartTLSRequest]</code></p>
<p>服务器收到请求后发送响应</p>
<blockquote>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadElement:(NSXMLElement *)element</code>接收到带<code>proceed</code>元素</p>
<blockquote>
<p><code>[self handleStartTLSResponse:element]</code></p>
<blockquote>
<p><code>[self startTLS]</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ol>
<li><p><code>- (BOOL)supportsInBandRegistration</code></p>
<p> 查看服务器是否支持带内（in-Band）注册</p>
</li>
<li><p><code>- (BOOL)registerWithElements:(NSArray *)elements error:(NSError **)errPtr;</code></p>
<p> 通过给定的元素进行新用户的注册</p>
<blockquote>
<p>建立<code>type</code>为<code>set</code>的IQ元素</p>
<p>建立<query>的NSXMLElement，将元素数组的元素全部加入进去</query></p>
<p>将<query>放入IQ</query></p>
<p>对xmlString通过压缩，编码，生成 outgoingData</p>
<p><code>[asyncSocket writeData:outgoingData withTimeout:TIMEOUT_XMPP_WRITE tag:TAG_XMPP_WRITE_STREAM]</code></p>
</blockquote>
</li>
<li><p><code>- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr;</code></p>
<p> 通过给定的用户名和密码建立一个用户账号</p>
<p> 将<code>username</code>和<code>password</code>两个元素添加到elements中并调用2的方法进行注册。</p>
</li>
</ol>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p><code>- (BOOL)authenticateWithPassword:(NSString *)inPassword error:(NSError **)errPtr</code></p>
<blockquote>
<p>选择一个最好的认证方法，共四种</p>
<p><code>[self authenticate:someAuth error:&amp;err]</code></p>
<blockquote>
<p><code>state = STATE_XMPP_AUTH</code></p>
<p><code>[inAuth start:&amp;err]</code></p>
<blockquote>
<p><code>- (void)sendAuthElement:(NSXMLElement *)element</code></p>
<blockquote>
<p><code>[asyncSocket writeData:outgoingData withTimeout:TIMEOUT_XMPP_WRITE tag:TAG_XMPP_WRITE_STREAM]</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h2><p>服务器相关信息来自rootElement，每次收到xml消息通过parser进行解析时，都要从头结点开始，就会触发相应的代理。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ol>
<li><p><code>- (void)sendElement:(NSXMLElement *)element</code></p>
<p> 一般情况下iq、message、presence、login都是通过该通用方法进行发送;</p>
<p> 如果element属于以上任何一个类型则使用对应的发送方法；如果不是则根据name通过object_setClass转换为对应类型；如果都不是则将element以压缩字符串的形式直接发送。</p>
</li>
<li><p><code>- (void)sendIQ:(XMPPIQ *)iq withTag:(long)tag</code></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知一切感兴趣的代理，为了能够以线程安全的方式改变元素(element)，需要连续进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取multicastDelegate的枚举，方便遍历</span></span><br><span class="line">GCDMulticastDelegateEnumerator *delegateEnumerator = [multicastDelegate delegateEnumerator];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(willSendIqQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow delegates to modify and/or filter outgoing element</span></span><br><span class="line"></span><br><span class="line">__block XMPPIQ *modifiedIQ = iq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> del;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (modifiedIQ &amp;&amp; [delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 确定代理方法(xmppStream:willSendIQ:)的返回值是否是(XMPPIQ *)</span></span><br><span class="line"><span class="keyword">char</span> methodReturnType[<span class="number">32</span>];</span><br><span class="line">Method method = class_getInstanceMethod([del class], selector);</span><br><span class="line">method_getReturnType(method, methodReturnType, <span class="keyword">sizeof</span>(methodReturnType));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strcmp(methodReturnType, @encode(XMPPIQ*)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"Method xmppStream:willSendIQ: is no longer void (see XMPPStream.h). "</span></span><br><span class="line"><span class="string">@"Culprit = %@"</span>, <span class="built_in">NSStringFromClass</span>([del class]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dq, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">// 提供通过外部delegate改变IQ的机会</span></span><br><span class="line">modifiedIQ = [del xmppStream:<span class="keyword">self</span> willSendIQ:modifiedIQ];</span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (modifiedIQ)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(xmppQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == STATE_XMPP_CONNECTED) &#123;</span><br><span class="line"><span class="comment">// 继续IQ的发送：压缩转码后通过[asyncSocket writeData:...]方法发送</span></span><br><span class="line">[<span class="keyword">self</span> continueSendIQ:modifiedIQ withTag:tag];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>- (void)sendLogin:(XMPPLogin *)login withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)sendMessage:(XMPPMessage *)message withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)sendPresence:(XMPPPresence *)presence withTag:(long)tag</code> 同2</p>
</li>
<li><p><code>- (void)injectElement:(NSXMLElement *)element</code></p>
<p> 该方法允许你将一个元素插入到流中，就好像是从socket接收到的消息一样，这创造了一些有趣的可能性。</p>
</li>
</ol>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>接收消息的过程：</p>
<blockquote>
<p>AsyncSocket的代理方法<code>- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</code>接收到数据</p>
<p><code>[parser parseData:data]</code></p>
<blockquote>
<p>触发parser的代理方法</p>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadRoot:(NSXMLElement *)root</code>拿到rootElement</p>
<p><code>- (void)xmppParser:(XMPPParser *)sender didReadElement:(NSXMLElement *)element</code>解析element，并根据state的状态分发下去：</p>
<blockquote>
<p><code>STATE_XMPP_NEGOTIATING</code>-&gt;<code>[self handleStreamFeatures]</code></p>
<p>该方法用来分析接收到的服务器的流特征，判断是否已经与服务器建立了连接</p>
<blockquote>
<p>根据features检查是否需要TLS，需要则<code>[self sendStartTLSRequest]</code></p>
<p>根据features检查是否支持资源绑定，需要则将<strong>资源绑定请求</strong>加入到iq中发送到服务器</p>
<p><code>state = STATE_XMPP_CONNECTED</code></p>
</blockquote>
<p><code>STATE_XMPP_STARTTLS_1</code>-&gt;<code>[self handleStartTLSResponse:element]</code></p>
<blockquote>
<p>如果返回的是”proceed”的元素，则成功，开始TLS协商；如果不成功则断开连接。</p>
</blockquote>
<p><code>STATE_XMPP_REGISTERING</code>-&gt;<code>[self handleRegistration:element]</code></p>
<blockquote>
<p>如果返回的元素的<code>type</code>不是”error”，则注册成功。</p>
</blockquote>
<p><code>STATE_XMPP_AUTH</code>-&gt;<code>[self handleAuth:element]</code></p>
<blockquote>
<p>如果认证成功，则再次开始协商。</p>
</blockquote>
<p><code>STATE_XMPP_BINDING)</code>-&gt;<code>[self handleBinding:element]</code></p>
<blockquote>
<p>如果能够拿到JID，说明资源绑定成功，检查是否需要建立对话，需要则开始IM会话，结束。</p>
<p>没有JID则尝试改变resource</p>
<p>通知代理，利用代理方法得到更改后的resource</p>
<p><code>[self continueHandleBinding:alternativeResource]</code></p>
<blockquote>
<p>有<code>alternativeResource</code>则添加到iq中发送</p>
<p>没有则让服务器来分配resource（通过发送<code>type</code>为”set”的iq）</p>
</blockquote>
</blockquote>
<p><code>STATE_XMPP_START_SESSION</code>-&gt;<code>[self handleStartSessionResponse:element]</code></p>
<blockquote>
<p><code>type</code>为”result”表示认证成功，回到<code>STATE_XMPP_CONNECTED</code>状态</p>
</blockquote>
<p><code>iq</code>-&gt;<code>[self receiveIQ:[XMPPIQ iqFromElement:element]]</code></p>
<blockquote>
<p>通知所有的代理，可在解析iq前改变或过滤iq</p>
<p><code>[self continueReceiveIQ:modifiedIQ]</code></p>
<blockquote>
<p>如果iq需要回复</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(xmppStream:didReceiveIQ:);</span><br><span class="line"><span class="comment">// 用信号量快速控制并发</span></span><br><span class="line">dispatch_semaphore_t delSemaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">dispatch_group_t delGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ([delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line">dispatch_group_async(delGroup, dq, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([del xmppStream:<span class="keyword">self</span> didReceiveIQ:iq])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 有代理方法对iq进行占用则发送一个信号</span></span><br><span class="line">dispatch_semaphore_signal(delSemaphore);</span><br><span class="line">&#125;	</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(didReceiveIqQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(delGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did any of the delegates handle the IQ? (handle == will response)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> handled = (dispatch_semaphore_wait(delSemaphore, DISPATCH_TIME_NOW) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端收到&lt;type&gt;为"get"或"set"的IQ请求时必须以&lt;type&gt;为"result"或"error"的iq来回复，并且回复的iq必须保留收到的iq的"id"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有代理来处理这个iq则返回带&lt;errro&gt;的iq</span></span><br><span class="line"><span class="keyword">if</span> (!handled)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 返回给服务器的错误信息：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;iq to="jid" type="error" id="id"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;query xmlns="ns"/&gt;</span></span><br><span class="line"><span class="comment">//   &lt;error type="cancel" code="501"&gt;</span></span><br><span class="line"><span class="comment">//     &lt;feature-not-implemented xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"/&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/error&gt;</span></span><br><span class="line"><span class="comment">// &lt;/iq&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSXMLElement</span> *reason = [<span class="built_in">NSXMLElement</span> elementWithName:<span class="string">@"feature-not-implemented"</span></span><br><span class="line">xmlns:<span class="string">@"urn:ietf:params:xml:ns:xmpp-stanzas"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSXMLElement</span> *error = [<span class="built_in">NSXMLElement</span> elementWithName:<span class="string">@"error"</span>];</span><br><span class="line">[error addAttributeWithName:<span class="string">@"type"</span> stringValue:<span class="string">@"cancel"</span>];</span><br><span class="line">[error addAttributeWithName:<span class="string">@"code"</span> stringValue:<span class="string">@"501"</span>];</span><br><span class="line">[error addChild:reason];</span><br><span class="line"></span><br><span class="line">XMPPIQ *iqResponse = [XMPPIQ iqWithType:<span class="string">@"error"</span></span><br><span class="line">to:[iq from]</span><br><span class="line">elementID:[iq elementID]</span><br><span class="line">child:error];</span><br><span class="line"><span class="comment">// 返回的iq中添加iq的子元素		</span></span><br><span class="line"><span class="built_in">NSXMLElement</span> *iqChild = [iq childElement];</span><br><span class="line"><span class="keyword">if</span> (iqChild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSXMLNode</span> *iqChildCopy = [iqChild <span class="keyword">copy</span>];</span><br><span class="line">[iqResponse insertChild:iqChildCopy atIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Purposefully go through the sendElement: method</span></span><br><span class="line"><span class="comment">// so that it gets dispatched onto the xmppQueue,</span></span><br><span class="line"><span class="comment">// and so that modules may get notified of the outgoing error message.</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> sendElement:iqResponse];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">dispatch_release(delSemaphore);</span><br><span class="line">dispatch_release(delGroup);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p><code>message</code>-&gt;<code>[self receiveMessage:[XMPPMessage messageFromElement:element]]</code></p>
<p><code>presence</code>-&gt;<code>[self receivePresence:[XMPPPresence presenceFromElement:element]]</code></p>
<p><code>cmcc_client_login</code>-&gt;<code>[self receiveLogin:[XMPPLogin loginFromElement:element]]</code></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="流协商"><a href="#流协商" class="headerlink" title="流协商"></a>流协商</h2><ol>
<li><p><code>- (void)startNegotiation</code></p>
<p> 用来开始初始的协商操作</p>
<blockquote>
<p><code>[self sendOpeningNegotiation]</code>初始化XML流</p>
<blockquote>
<p>通过socket发送&lt;?xml version=’1.0’?&gt;，</p>
<p>初始化或重启parser，从而将self赋值给parser的代理，从而可以在XMPPStream中实现parser的代理方法。</p>
<p>发送<stream:stream xmlns="%@" xmlns:stream="%@" version="1.0" to="%@"></stream:stream></p>
</blockquote>
<p><code>[multicastDelegate xmppStreamDidStartNegotiation:self]</code></p>
<p><code>[asyncSocket readDataWithTimeout:TIMEOUT_XMPP_READ_START tag:TAG_XMPP_READ_START]</code></p>
</blockquote>
</li>
<li><p><code>- (void)startTLS</code></p>
<p> 根据正确的设置，开始TLS协商，在”安全”章节中有提到。</p>
</li>
</ol>
<h2 id="心跳数据"><a href="#心跳数据" class="headerlink" title="心跳数据"></a>心跳数据</h2><p><code>- (void)setupKeepAliveTimer</code>设置心跳数据计时器</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">keepAliveTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, xmppQueue);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(keepAliveTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">// 发送心跳数据	</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> now = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line"><span class="built_in">NSTimeInterval</span> elapsed = (now - lastSendReceiveTime);</span><br><span class="line"><span class="comment">// 如果长达2分钟没有通信发生则发送心跳数据</span></span><br><span class="line"><span class="keyword">if</span> (elapsed &lt; <span class="number">0</span> || elapsed &gt;= keepAliveInterval)</span><br><span class="line">&#123;</span><br><span class="line">numberOfBytesSent += [keepAliveData length];</span><br><span class="line"></span><br><span class="line">[asyncSocket writeData:keepAliveData</span><br><span class="line">withTimeout:TIMEOUT_XMPP_WRITE</span><br><span class="line">tag:TAG_XMPP_WRITE_STREAM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制更新	lastSendReceiveTime，以防TCP socket通信由于传送巨大而缓慢	</span></span><br><span class="line">lastSendReceiveTime = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">uint64_t interval = ((keepAliveInterval / <span class="number">4.0</span>) * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">// 设置计时器的开始时间-延时30s</span></span><br><span class="line">dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, interval);</span><br><span class="line"><span class="comment">// 以30s为间隔发送心跳数据</span></span><br><span class="line">dispatch_source_set_timer(keepAliveTimer, tt, interval, <span class="number">1.0</span>);</span><br><span class="line">dispatch_resume(keepAliveTimer);</span><br></pre></td></tr></table></figure>
<h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ol>
<li><p>AsyncSocket</p>
<ul>
<li><p><code>- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code></p>
<blockquote>
<p><code>[self endConnectTimeout]</code>取消超时处理</p>
<p><code>[asyncSocket enableBackgroundingOnSocket]</code>开启socket的后台监听</p>
<p><code>[self startTLS]</code></p>
<p><code>[self startNegotiation]</code></p>
</blockquote>
</li>
<li><p><code>- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</code></p>
<blockquote>
<p><code>[parser parseData:data]</code></p>
<p><code>[asyncSocket readDataWithTimeout:TIMEOUT_XMPP_READ_STREAM tag:TAG_XMPP_READ_STREAM]</code>继续读取xml元素</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>从中可以看出，XMPPStream是一个设计严谨，线程安全的消息通讯类型，其风格包括：</p>
<ol>
<li>为了保证线程安全：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t block = ^&#123;</span><br><span class="line"><span class="comment">// 要在xmpp线程中运行的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (dispatch_get_specific(xmppQueueTag))</span><br><span class="line">block();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(xmppQueue, block);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<ol>
<li>如何通知带返回值的代理方法<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(对应的代理方法)</span><br><span class="line"><span class="keyword">if</span> (![multicastDelegate hasDelegateThatRespondsToSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// None of the delegates implement the method.</span></span><br><span class="line"><span class="comment">// Use a shortcut.</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">GCDMulticastDelegateEnumerator *delegateEnumerator = [multicastDelegate delegateEnumerator];</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ([delegateEnumerator getNextDelegate:&amp;del delegateQueue:&amp;dq forSelector:selector])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dq, ^&#123;<span class="keyword">@autoreleasepool</span></span><br><span class="line">&#123;</span><br><span class="line">[del 对应的代理方法];</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​</p>
<blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记:"></a>后记:</h2><p>本文只是在看源代码过程中对个人简介的一点梳理，由于能力所限，无论排版还是内容理解都有所欠缺，如有错误还请见谅，该文以后还会改进与更新。<br>下一篇文章为多重代理的原理与实现，敬请期待。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://xenobladex.github.io/2016/05/31/XMPPFramework源码分析-三-流/" data-id="ciov8nedr0004iu2wee0zipc8" class="article-share-link">分享到</a><div class="tags"><a href="/tags/XMPP/">XMPP</a></div><div class="post-nav"><a href="/2016/05/31/IOS编译打包提交自动化/" class="pre">IOS编译打包提交自动化</a><a href="/2016/05/19/XMPPFramework源码分析-二-JID/" class="next">XMPPFramework源码分析&lt;二&gt; - JID</a></div><div data-thread-key="2016/05/31/XMPPFramework源码分析-三-流/" data-title="XMPPFramework源码分析&lt;三&gt; - 流" data-url="http://xenobladex.github.io/2016/05/31/XMPPFramework源码分析-三-流/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/05/31/XMPPFramework源码分析-三-流/" data-title="XMPPFramework源码分析&lt;三&gt; - 流" data-url="http://xenobladex.github.io/2016/05/31/XMPPFramework源码分析-三-流/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Applescript/" style="font-size: 15px;">Applescript</a> <a href="/tags/编译/" style="font-size: 15px;">编译</a> <a href="/tags/XMPP/" style="font-size: 15px;">XMPP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/31/IOS编译打包提交自动化/">IOS编译打包提交自动化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/31/XMPPFramework源码分析-三-流/">XMPPFramework源码分析<三> - 流</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/19/XMPPFramework源码分析-二-JID/">XMPPFramework源码分析<二> - JID</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/19/XMPPFramework源码分析-一-消息/">XMPPFramework源码分析<一> - 消息</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/18/多重委托-MultiDelegate-官方解释/">多重委托(MultiDelegate)官方解释</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/18/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">The Zohar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'xenobladex'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>